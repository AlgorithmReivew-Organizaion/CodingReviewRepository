public static class Solution {
        public boolean searchMatrix(int[][] matrix, int target) {
            int rowLen = matrix.length; //행의 길이(세로 길이)
            int colLen = matrix[0].length; //열의 길이(가로 길이)

            int leftIndex = 0;
            int rightIndex = colLen - 1;
            int upIndex = 0;
            int downIndex = rowLen - 1;
            int midIndex = 0;
            int findPoint = 0;

            //가로와 세로 각각 이분탐색으로 찾는다.

            //먼저, 이차원 배열이지만 원소가 하나라면, target과 비교하고 바로 끝냄
            if(rowLen == 1 && colLen == 1 && matrix[0][0] == target ) return true;

            //가로로는 우선 비교를 하기 때문에 상관없지만, 만약 가로 길이가 1이면, while문에 들어가지 않아서 세로로는 비교하지 않게 된다.
            //따라서 가로 길이가 1이 아닐때(일반적일때)와 1일때로 나누어서 생각한다.
            if(colLen != 1) {
                while (leftIndex < rightIndex) { //이분탐색응로 첫째 행에서 target수가 있다면 종료, 없다면 target보다 작은 수 중 가장 큰 수가 있는 열의 위치를 findpoint에 저장
                    midIndex = (leftIndex + rightIndex) / 2;
                    if (matrix[0][midIndex] == target || matrix[0][leftIndex] == target || matrix[0][rightIndex] == target) {
                        return true;
                    } else if (matrix[0][midIndex] > target) {
                        rightIndex = midIndex;
                    } else leftIndex = midIndex + 1;

                }
                if(leftIndex == colLen-1) {//만약 leftPoint가 이미 오른쪽 끝에 있다면 그 위치를 findPoint로 잡고 끝냄
                    findPoint = leftIndex;
                }
                else{ //아니라면 findPoint는 leftPoint보다 1작은 인덱스
                    findPoint = leftIndex - 1;
                }
            }
            else{ //가로 길이가 1인 경우는 세로로만 비교해주면서 찾아본다.
                while(upIndex < downIndex){
                    midIndex = (upIndex + downIndex) / 2;
                    if(matrix[midIndex][0] == target || matrix[upIndex][0] == target || matrix[downIndex][0] == target ){
                        return true;
                    }
                    else if(matrix[midIndex][0] > target){
                        downIndex = midIndex;
                    }
                    else upIndex = midIndex + 1;
                }
                return false;
            }


            //일반적인 경우, 첫행에서 찾아낸 열을 기준으로 세로로 비교하고, 그 열에서 없다면 열을 한칸씩 왼쪽으로 옮겨가면서 반복비교
            for(int i = findPoint; i >= 0; i--){
                while(upIndex < downIndex){
                    midIndex = (upIndex + downIndex) / 2;
                    if(matrix[midIndex][i] == target || matrix[upIndex][i] == target || matrix[downIndex][i] == target ){
                        return true;
                    }
                    else if(matrix[midIndex][i] > target){
                        downIndex = midIndex;
                    }
                    else upIndex = midIndex + 1;
                }

                //한 열의 비교가 모두 끝났는데 없다면 upIndex와 downIndex를 초기화하고 열을 이동한다.
                upIndex = 0;
                downIndex = rowLen -1;
            }
            return false;
        }
    }

import java.io.IOException;
import java.sql.Timestamp;
import java.util.*;

class Twitter {
        //누가 누구를 follow하는지 확인. index에 해당하는 id가 그 값에 해당하는 사람을 follow한다.
        ArrayList<Integer>[] followCheck = new ArrayList[501];
        //누가 어떤 게시물을 올렸는지 저장하는 map. key는 userId, value는 트윗정보 객체의 ArrayList
        HashMap<Integer, ArrayList<TweetInfo>> posts = new HashMap<>();
				//누가 올리든 게시물을 하나 게시할때마다 1씩 증가해서 순서를 알려줄 변수
        int order = 0;
        class TweetInfo{

            int tweetId;
            int rank = 0; //게시물을 게시할때마다 order값을 여기 넣어준다.

            TweetInfo(){};

            TweetInfo(int tweetId, int rank){
                this.tweetId = tweetId;
                this.rank = rank;
            }

        }
        public Twitter() {

        }

        public void postTweet(int userId, int tweetId) {
            order += 1;
            TweetInfo tempInfo = new TweetInfo(tweetId, order);
            ArrayList<TweetInfo>  info1 = new ArrayList<>();
						//만약 userId에 해당하는 사용자가 게시한 이력이 있다면 그 배열에 정보 가
            if(posts.containsKey(userId)){
                info1 = posts.get(userId);
                info1.add(tempInfo);
                posts.put(userId, info1);
                return;
            }
						//게시한 이력이 없다면 배열 만들어서 해시맵에 추가
            info1.add(tempInfo);
            posts.put(userId, info1);
        
        }

        public List<Integer> getNewsFeed(int userId) {
            List<Integer> answer = new ArrayList<>();
            ArrayList<Integer> follow = new ArrayList<>();
            ArrayList<TweetInfo> forProcess = new ArrayList<>();
						
						//팔로우 하는 사람이 있는지 확인하고 있다면 팔로우 목록을 가져온다.
            if(followCheck[userId] != null) {
                follow = followCheck[userId];
            }
						
						//팔로우 목록에 있는 사람들이 올린 게시물을 forProcess배열에 가져옴
            if(follow != null) {
                for (int id : follow) {
                    if(posts.get(id) != null) {
                        for (TweetInfo ti : posts.get(id)) {
                            forProcess.add(ti);
                        }
                    }
                }
            }
						//자기가 올린 게시물도 forProcess 배열에 가옴
            if(posts.get(userId) != null) {
                for (TweetInfo ti : posts.get(userId)) {
                    forProcess.add(ti);
                }
            }
						//그 배열을 최근에 올린 순으로 열
            forProcess.sort(new Comparator<TweetInfo>() {
                @Override
                public int compare(TweetInfo o1, TweetInfo o2) {

                    return o1.rank > o2.rank ? -1 : 1;
                }
            });
						//정렬을 했으므로, 순서대로 10개 가져와서 tweetId만 저장 후환
            for(int i = 0; i < forProcess.size(); i++){
                if(i > 9) break;
                if(forProcess.get(i) != null) {
                    answer.add(forProcess.get(i).tweetId);
                }
                else break;
            }


            return  answer;
        }

				//followerId를 인덱스로 해서 자신이 팔로우 하는 사람들의 목록을 배열에 장
        public void follow(int followerId, int followeeId) {
            ArrayList<Integer> temp = new ArrayList<>();
            temp.add(followeeId);
            if (followCheck[followerId] != null) {
                temp = followCheck[followerId];
                if(temp.contains(followeeId)){
                    return;
                }
                temp.add(followeeId);
                followCheck[followerId] = temp;
            }
            followCheck[followerId] = temp;
        }
				//followerId가 팔로우하는 사람들의 목록을 가져와서 언팔할 사람을 제
        public void unfollow(int followerId, int followeeId) {
            if(followCheck[followerId] != null) {
                followCheck[followerId].remove((Integer) followeeId);
            }
        }
    }
